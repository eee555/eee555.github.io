# 施工中。。。

+ py_refreshMatrix(BoardofGame: Vec<Vec<i32>>) -> PyResult<(Vec<Vec<i32>>, Vec<(usize, usize)>, Vec<i32>)>



``` python
import ms_toollib as ms
board = [
    [ 1, 10, 10, 10, 10, 10, 10, 10],
    [ 1, 10, 10, 10, 10, 10, 10, 10],
    [ 2, 10, 10, 10, 10, 10, 10, 10],
    [10, 10, 10, 10, 10, 10, 10, 10],
    [10, 10, 10, 10, 10, 10, 10, 10],
    [10, 10, 10, 10, 10, 10, 10, 10],
    [10, 10, 10, 10, 10, 10, 10, 10],
    [10, 10, 10, 10, 10, 10, 10, 10],
]; # 10代表没有打开的格子
p = ms.cal_possibility(board, 10)
# 根据局面和除去标雷后的剩余雷数，计算每格是雷的概率
print(p)

>>> ([((0, 1), 0.07547169811320754), ((1, 1), 0.9245283018867925), ((2, 1), 0.0), ((3, 0), 0.5377358490566038), ((3, 1), 0.5377358490566038)], 0.14150943396226415)

board = [
    [ 0,  0, 11, 10, 10, 11,  0,  0],
    [ 0,  0, 11,  4,  4, 11,  0,  0],
    [ 0,  0, 11,  0,  0, 11,  0,  0],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [0,  0, 11,  0,  0, 11,  0,  0],
    [0,  0, 11,  4,  4, 11,  0,  0],
    [0,  0, 11, 10, 10, 11,  0,  0],
]; # 11代表标雷
p = ms.cal_possibility(board, 2)
print(p)

>>> ([((0, 3), 0.5), ((0, 4), 0.5), ((7, 3), 0.5), ((7, 4), 0.5)], nan)

ms.layMineSolvable_thread(8,8,10,0,0)
# 根据宽高、雷数、起手位置，用多线程的方式无猜埋雷

>>> ([[0, 0, 0, 0, 0, 2, -1, 2], [0, 0, 0, 0, 0, 2, -1, 2], [0, 0, 1, 1, 1, 1, 2, 2], [0, 1, 2, -1, 2, 2, 3, -1], [0, 1, -1, 2, 2, -1, -1, 3], [0, 1, 1, 1, 1, 3, -1, 2], [0, 1, 1, 2, 1, 2, 1, 1], [0, 1, -1, 2, -1, 1, 0, 0]], [1, 21, 1])
```